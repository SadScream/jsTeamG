# Game Flappy Bird

Копия популярной мобильной игры Flappy Bird, написанная на языке JavaScript. [Играть](https://progivt19.github.io/jsTeamG/)

---

## Основное
При загрузке страницы в блоке `span` и `span#osts` подгружаются используемые изображения и музыка. Для создания графики используется элемент `canvas`.

При запуске скриптового файла `game.js` создается экземпляр элемента canvas с последующим созданием объекта контекстного рисования в режиме двумерной графики. Также задаются настройки шрифта.
```JS
let
	canvas = document.getElementById('canvas'),
	ctx = canvas.getContext('2d');

ctx.fillStyle = "#000";
ctx.font = "bold 21px Calibri";
```

Далее создаются объекты изображений, звуков и музыки с указанием путей к оным. А также игровые переменные по типу позиции птички и счета.
```JS
let bg = new Image(); // фон
bg.src = "assets\\background.png";

// позиция птички, скорость ее постоянного снижения; то, насколько будет птичка подниматься при каждом нажатии на space; то, как быстро птичка будет достигать этой величины
let xPos, yPos, gravity, offset, offset_per_iteration;
```

По наступлению события загрузки последнего элемента фоновой музыки вызывается анонимная функция, возвращающая вызов функцию `reload`. Эта функция вызывается также и при поражении. В ней все значения игровых переменных, кроме переменной `record`, переходят к значению по умолчанию, а также к событию клика по полотну(canvas) присваивается вызов функции start.

```JS
let moveUp = function(e) {
	/*
	в качестве аргумента передается объект <События нажатия>, содержащий в себе информацию о нем(например, то, какая клавиша была нажата)
	выполняется гладкая анимация полета птички, за счет последовательного изменения ее положения и последующей смены кадра
	анимация(взмах крыльями) достигается переменной сменой изображений из списка state
	после выполнения операции взлета проигрывается звук взмаха
	*/

	...
}

let start = function() {
	/*
	включает случайную фоновую музыку
	отсоединяет эту функцию от события клика по канвасу
	присваивает к событию нажатия на клавиву вызов функции moveUp
	очищает канвас от элементов предыдущего экрана
	вызывает основную функцию loop
	*/

	...
}

let reload = function() {
	/*
	дефолтные значения переменных
	создание начального экрана при загрузке страницы или после поражения
	*/

	...
	canvas.addEventListener('click', start); // присоединяем событие клика на начальном экране к функции start
}

ostList[ostList.length-1].onloadeddata = () => reload();
```

---

## Механика

После того, как была вызвана функция loop, происходит ее выполнение, заключающееся в следующем:
1. Отрисовка фона `ctx.drawImage(bg, 0, 0);`
2. Последовательная отрисовка каждого из препятствий. Отрисовка происходит следующим образом: из списка pipe берется объект с координатами - это верхнее препятствие, оно рисуется как раз по этим координатам; нижнее же препятствие рисуется соответственно верхнему по формуле:
`<положение верхнего препятствия по Y(pipe[i].y)> + <высота(pipeUp.height) верхнего препятствия> + <пробел(gap)>`
Положение по X у обоих препятствий всегда одинаковое, при "спавне" оно всегда равно canvas.width, при каждой следующей итерации их положение по X меняется на значение `speed` в левую сторону. Первое препятствие было создано при вызове функции reload, и оно имело координаты:
`x: canvas.width(положения по иксу равно ширине полотна и соответственно препятствие находится вне его) y: 0`
```JS
for(let i = 0; i < pipe.length; i++) {
	ctx.drawImage(pipeUp, pipe[i].x, pipe[i].y);
	ctx.drawImage(pipeDown, pipe[i].x, pipe[i].y + pipeUp.height + gap);

	pipe[i].x -= speed;
```
3. Проверка в том же цикле, соответствует ли положение данного препятствия(pipe[i]) по оси X заданному минимальному значению, пересечение которого знаменует появление "за сценой" нового препятствия. Положение нового препятствия по X задается все также значение длины полотна, значение же Y-координаты задается числом равным значению случайного элемента в промежутке [-(pipeUp.height-50); 0].
```JS
if (pipe[i].x == 100) {
	pipe.push({
		x: canvas.width,
		y: -1 * (Math.floor(Math.random() * (pipeUp.height-50)))
	});
}
```
3. Проверка, не коснулась ли птичка земли или какого либо из препятствий в том же цикле. Если `позиция птички по Y + высота ее модельки больше, либо равна высоте полотна`, то птичка явно коснулась земли. Если `позиция птички по X + длина ее модельки больше, либо равна положению препятствия по X`, а также `ее позиция по X меньше, либо равна положению препятствия по X + длине модельки препятствия`, то положения птички сейчас в пределах препятствия по оси X и тогда нужно проверить, находится ли она в пределах препятствий по оси Y. Если `позиция птички по Y больше, либо равна положению нижней части верхнего препятствия` или `позиция птички по Y меньше, либо равна положению верхней части нижнего препятствия`, то птичка явно коснулась его. Если условие выполняется, происходит возврат вызова функции fall(), описывающей действия в случае поражения, а также проверяется, был ли побит предыдущий рекорд.
```JS
if (xPos + bird.width-5 >= pipe[i].x) { // птичка вошла в позицию стены
	if (xPos+10 <= pipe[i].x + pipeUp.width) { // птичка еще не прошла через стены
		if ( (yPos+3 <= pipe[i].y + pipeUp.height) || (yPos + bird.height >= pipe[i].y + pipeUp.height + gap) ) {
			// если позиция птички по Y меньше позиции нижней части верхней стены
			// либо позиция птички по Y больше позиции верхней части нижней стены

			if (score > record) { // по умолчанию record = 0
				record = score;
			}

			return fall();
```
4. Проверка в том же цикле, соответствует ли положение данного препятствия(pipe[i]) по оси X заданному минимальному значению, пересекая которое препятствие считается пройденным. Если так, то счет(score) увеличивается на 1 и проигрывается соответствующий звук.
```JS
if(pipe[i].x == -50) {
	score++;
	score_audio.play();
}
```
5. По завершению работы цикла отрисовывается позиция птички(по X - постоянное значение, по Y - с каждым вызовом функции loop уменьшается на значение gravity); отображается текущий счет и рекорд(если таковой был поставлен ранее); запрашивается следующий фрейм.
```JS
ctx.drawImage(bird, xPos, yPos);
yPos += gravity; // действие гравитации
ctx.fillText("Счет: " + score, 5, 20);

if (record != 0) {
	ctx.fillText("Рекорд: " + record, 5, 40);
}

timer = requestAnimationFrame(loop);
```
6. Если птичка коснулась препятствия, функция loop возвращает вызов функции fall(). Та в свою очередь отсоединяет событие нажатия на клавишу от функции moveUp, дорисовывает фрейм, отрисовка которого была прервана, прекращает выполнение последней анимации, содержащейся в `animation_` и `timer`, останавливает фоновую музыку, проигрывает звук удара о препятствие, выставляя небольшую паузу за счет асинхроноого вызова ожидающей функции sleep, увеличивает значение `gravity`, меняет состояние птички `bird.src = state[2];` и выполняет вызов вложенной функции fall_. Функция fall_ выполняет почти те же действия по отрисовке, что и функция loop. Вызов прекращается как только позиция птички по Y превышает высоту полотна.
```JS
if (yPos > canvas.height) {
	await sleep((game_over.duration - game_over.currentTime)*1000); // ожидания окончания проигрыша мелодии поражения
	ctx.clearRect(0, 0, canvas.width, canvas.height); // очистка канваса
	bird.src = state[0]; // смена состояния на обычное
	return reload(); // колесо сансары дало оборот
}
```